# Теория. Билет 18 "Главная пара и главный тип. Теорема Хиндли-Милнера" (Денис Шестаков)

## Напоминание

У нас есть два алгоритма: алгоритм унификации и алгоритм построения системы ограничений

![alt text](https://ie.wampi.ru/2021/12/24/16.1.png)

![alt text](https://ie.wampi.ru/2021/12/24/17.1.png)

## Главная пара

![alt text](https://ie.wampi.ru/2021/12/24/17.4.png)

## Теорема Хиндли-Милнера

Собственно сама теорема и её доказательство - алгоритм

![alt text](https://ie.wampi.ru/2021/12/24/17.5.png)

Стартовые переменные, которые мы задаем свободным переменным контекста и типу должны быть *свежими*.

## Главный тип

Главный тип все равно что главная пара, только с пустым контекстом, потому что терм замкнутый.

![alt text](https://ie.wampi.ru/2021/12/24/17.6.png)

## Мощь теоремы Хиндли-Милнера

Теперь мы умеем решать уравнения на переменные:

![alt text](https://ie.wampi.ru/2021/12/24/18.4.png)

Решения:

![alt text](https://ie.wampi.ru/2021/12/24/18.5.png)

## Проблема и её решение let-полиморфизмом

![alt text](https://ie.wampi.ru/2021/12/24/18.6.png)

Мы получаем какую-то функцию *f*, действующую из *a* в *b*. Запуская алгоритм поиска главной пары
система ограничений говорит нам, что *a* - это *Char*, а потом что *a* - это *Bool*. Получаем ошибку.
Но проблема в том, что мы можем передать какую-то полиморфную функцию, например *Id*.

Такая проблема решается let-полиморфизмом, когда наш редекс сконструирован явно. 

![alt text](https://ie.wampi.ru/2021/12/24/18.7.png)

К сожалению это тоже работает не всегда. Но все решается расширением.
Для этого нужно явно объявлять функцию полиморфной через *forall*.

![alt text](https://ie.wampi.ru/2021/12/24/18.8.png)