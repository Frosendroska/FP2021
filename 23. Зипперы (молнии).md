# Зипперы
### Проблемы неизменяемости
В хаскель внесение изменений в структуру данных может быть проблематичным (изменить последний элемент списка, изменить элемент дерева). Может потребоваться снимать конструкторы, менять элемент и потом обратно эти конструкторы возвращать. На примере тройки это хорошо видно:
```haskell
update :: new -> (a, (old, c)) -> (a, (new, c))
update2 v (x,(_,z)) = (x,(v,z)) --снимаем два конструктора, реконструируем
```
При этом мы меняем структурно-ссылочную вещь, получаем новый объект.
```haskell
GHCi> stru = (1,(2,(3,4)))
GHCi> update2 42 stru
(1,(42,(3,4)))
GHCi> update2 "Hello" stru
(1,("Hello",(3,4)))
```
### Понятие зиппера
Идея -- сделать структуру похожую на данную, которая обеспечивает
- возможность навигации по стр-ре (какой-то элмент, находится в фокусе, а фокус мы двигаем)
- эффективную модификацию элемента в текущем месте
  (фокусе, hole) внутри структуры (легко поменять эл-т и к другим рядом лежащим эл-там есть быстрый доступ)

Для примера с тройкой
```haskell
type Triple a = (a,(a,a))
type TripleZ a = (a, -- фокус
                  Cntx a) -- контекст
data Cntx a = C1 ((),(a,a)) | C2 (a,((),a)) | C3 (a,(a,())) -- можем вытащить элемент либо 1-й, либо 2-й, либо 3-й
```
Фокус -- элемент структуры, который вытаскиавется и держится отдельно
Контекст -- вся оставшаяся структура, кроме фокуса (определяется для каждого типа данных по-своему).
### Зиппер для списка
Ниже описывается только идея без рассмотрения крайних случаев.
```haskell
type ListZ a = (a, CntxL a) --эл-т списка и контекст
type CntxL a = ([a],[a]) --"голова" до элемента, хвост за элементом

--Зиппер из обычного списка
mklz :: [a] -> ListZ a
mklz (x:xs) = (x,([],xs))
```
```haskell
GHCi> lz = mklz [0..3]
(0,([],[1,2,3]))
```
Как двигаться по структуре? Мы должны смещать фокус в ту или иную сторону.
```haskell
fwd :: ListZ a -> ListZ a
fwd (e, (xs, y:ys)) = (y, (e:xs, ys)) --сняли первый из хвоста, е записали в "голову". "Голова" развернута!

bwd :: ListZ a -> ListZ a
bwd (e, (x:xs, ys) = (x, (xs, e:ys))

--Из зипера в список
unlz :: ListZ a -> [a]
unlz (x,([],xs)) = x:xs
unlz z = unlz (bwd z)
```
```haskell
GHCi> fwd lz
(1,([0],[2,3]))
GHCi> (fwd . fwd) lz
(2,([1,0],[3]))
GHCi> lz’ = (fwd . fwd) lz
(2,([1,0],[3]))
GHCi> bwd lz’
(1,([0],[2,3]))
GHCi> unlz lz’
[0,1,2,3]
```
Значение в фокусе можно быстро поменять
```haskell
updLZ :: a -> ListZ a -> ListZ a
updLZ v (_,ctx) = (v,ctx) --просто менем, контекст тот же
insLZ :: a -> ListZ a -> ListZ a
insLZ v (e,(xs,ys)) = (v,(xs,e:ys)) --ставим на место пред, пред в хвост
delLZ :: ListZ a -> ListZ a
delLZ (e,(xs,y:ys)) = (y,(xs,ys)) --фокус из хвоста
delLZ (e,(x:xs,[])) = (x,(xs,[])) --если хвост пустой то с головы

--Примеры
GHCi> (unlz . updLZ 42 . fwd . fwd . mklz) [0..3]
[0,1,42,3]
GHCi> (unlz . insLZ 33 . insLZ 42 . fwd . fwd . mklz) [0..3]
[0,1,33,42,2,3]
```

### Как определить контекст с дыркой
Вообще типы можно дифференцировать и выполняются правила дифференцирования. То есть для нахождения контекста нам надо продифференцировать тип по его параметру. На примере списка

```haskell
L(x) = 1 + x + x^2 + ...
--В виде рекурсивного уравнения
L(x) = 1 + x * (x +  x^2 + ...)
L(X) = 1 + x * L(x)  ---->   L(x) = 1 / (1 - x)
--Тогда 
L'(x) = 1 / (1 - x)^2
L'(x) = L(x) * L(x)
```
Заметим, что ```type CntxL a = ([a],[a])``` как раз и есть два списка.
Аналогично можно опредлить зиппер для других структур. Определим контекст для бинарного дерева
```haskell
T(x) = = 1 + x * T^2(x)
T'(x) = T^2(x) + 2x * T(x) * T'(x)
T'(x) = T^2(x) /  (1 - 2 * X * T(X))
--используя список
T'(x) = T(x) * T(x) *  L(2 * X * T(X))
```
То есть контекст с дыркой для дерева это 2 дерева и список, который задает направление спуска (L, R), корень поддерева откуда спускаемся и поддерево, в которое не пойдем. На примере следующего дерева где фокусе лежит _
```haskell
        1
       / \
      /   \
     /     \
    2       5   
   / \     / \   = (    8  , 7 , [(R, 1,   5   ), (L, 2, 5)]
  5   _   4   8        / \                / \
     / \              2   3              4   8
    8   7
   / \
  2   3
```
