# Основы программирования на Haskell. Связывание. Рекурсия. Базовые конструкции языка

Кортеж (tuple) - значения произвольных типов, разделенные запятыми и заключенные в круглые скобки. Минимальный размер - 2, максимальный не меньше 15 по стандарту
Список (list) - похож на кортеж, но тип элементов должен быть одним, а размер не ограничен

## Связывание

Для связывания (binding) используется знак равенства, где имя слева от знака связывается с выражением справа, например:

``` haskell
x = 42               -- глобальное
sq = let z = x + y   -- abc - глобальное, z локальное
	in z ^ 2         
y = 13 + 6           -- глобальное
```

Первый символ индефикатора должен быть в нижнем регистре. Можно говорить про связывание как про объявление констант или функций нулевой арности.

Связвывать можно не только одну переменную, а сразу несколько:

``` haskell
GHCI> (x, y) = ("Hehe", "hihi")
GHCI> y
"hihi"
GHCI> [a, b, c] = "hah" -- не (a, b, c) т.к. hah - [Char]
GHCI> b
'a'
GHCI> [c, d, e] = "UHUHUHUHUHUU" -- компилируется
GHCI> c
*** Exception: <interactive>:4:1-26: Non-exhaustive patterns in [c, d, e]
```

Так же есть функциональное связывание, в примере функция связывается глобально, а x и y локально

``` haskell
foo x y = x + y -- определили foo
```
Есть разные стили, для определения функций
``` haskell
foo x y = 10 * x + y       -- комбинаторный стиль
foo' x = \y -> 10 * x + y  -- смешанный стиль
foo'' = \x y -> 10 * x + y -- лямбда-стиль
```

Так же есть бесточечный стиль. Смысл в том, что в определении нет точки принения функции - ее аргумента. 

``` haskell
lg x = logBase 2 x  -- комбинаторное определение 
lg' = logBase 2     -- бесточечный стиль
```

Связывание просиходит единожды (в лексической области видимости)!!! 

```haskell
z = 1
z = 2 -- ошибка, повторное связываение. Но в интерпретаторе допустимо
a a = a -- ок, так как первая a - связывается глобально, а вторая локально
a a a = a -- ошиибка, так как первая а - глобально, а вот 2 и 3 связываются локально - происходит коллизия
```
## Рекурсия
Рекурсивное определение должно содержать имя определяемой функции в теле. Для того чтобы реализация была корректной она должна содрежать терминирующее условие. Посмотрим на пример с факториалом:
``` haskell
factorial n = if n == 0
			  then 1
              else n * factorial (n - 1)
```

Но не всегда наивная реализация бывает эффективной. Для того, чтобы сохранить линейную по числу рекурснивных вызовов сложность используют версию с аккумулятором. Для факториала она выглядит так

``` haskell
factorial' n = helper 1 n
	where helper acc n = if n > 1
						 then helper (acc * n) (n - 1)
						 else acc
```

## Базовые конструкции
* Конструкция where обеспечивает локальное свзяывение вспомогательных функцийи переменных , например для реализации функции factorial' мы использовали helper, которую связали локаьлно с помощью where. Пример не с функией, а с переменными
``` haskell
abc x y z = hihi + z - haha
	where hihi = sqrt x
		  haha = 2 * y
```
* Выражение let .. in .. похожа на where, и отличается только порядком следования блоков, где переменные связываются и используются
``` haskell
abc x y z = 
	let hihi = sqrt x
		haha = 2 * y
	in hihi + z - haha
```
* Предохранители. вместо того, чтобы писать много if можем делать guard, просматриваются сверху вниз.  Факториал с предохранителями:
``` haskell
factorial`` n = helper 1 n
	where helper acc n | n > 1 = helper (acc * n) (n - 1)
					   | otherwise = acc
```



