# Теория. Билет 5 "Кодирование чисел Чёрча в чистом бестиповом λ-исчислении. Арифметические операции над ними"

## Предисловие

Я не знаю, как глубоко надо было зайти с этим билетом, тут есть основные арифметические операции `++, --, +, -, *, ^`

## Натуральные числа (числа Чёрча)


Договоримся, что
```haskell
> 0 = \s z → z
> 1 = \s z → s z                  [fun fact: 1 = iff = id]
> 2 = \s z → s (s z)              [notice: не \s z → s s z]
> 3 = \s z → s (s (s z))
> 4 = \s z → s (s (s (s z)))
> 5 = \s z → s (s (s (s (s z))))
> ...
```

## succ

Определим операцию succ, делающую +1
```haskell
> succ 0 = 1
> succ 1 = 2
> ...
```

```haskell
> succ  = \n s z → n s (s z)
> succ' = \n s z → s (n s z)
```

## plus

Определим при помощи неё plus

Ответ:
```haskell
> plus = \n m s z → n s (m s z)
> plus' = \n m → n succ m
> plus'' = \n m → m succ n
```

```haskell
plus 2 3 =>
(\n m → n succ m) 2 3 =>
2 succ 3 =
(\s z → s (s z)) succ 3 =>
succ (succ 3) =>
5
```

Далее материал скопирован [Отсюда](https://neerc.ifmo.ru/wiki/index.php?title=%D0%9B%D1%8F%D0%BC%D0%B1%D0%B4%D0%B0-%D0%B8%D1%81%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5#.D0.9D.D1.83.D0.BC.D0.B5.D1.80.D0.B0.D0.BB.D1.8B_.D0.A7.D1.91.D1.80.D1.87.D0.B0_.D0.B8_.D0.BF.D1.80.D0.BE.D0.B3.D1.80.D0.B0.D0.BC.D0.BC.D0.B8.D1.80.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5_.D0.BD.D0.B0_.5Bmath.5D.5Clambda.5B.2Fmath.5D-.D0.B8.D1.81.D1.87.D0.B8.D1.81.D0.BB.D0.B5.D0.BD.D0.B8.D0.B8) 

## mull

Умножение похоже на сложение, но прибавлять надо не единицу, а второе число. Или, в терминах нумералов Чёрча, в качестве применяемой несколько раз функции должна быть не s, а функция, применяющая n раз s.

```haskell
>mult=λn . λm . λs . λz . n (m s) z
```

Здесь m s — функция, которая m раз применит s к тому, что дадут ей на вход. С помощью η-редукции можно немного сократить эту формулу

```haskell
mult=λn . λm . λs . n (m s)
```

```haskell
GHCi> mult 3 3
9
```

## power

It's a kind of magic

```haskell
power=λn . λm . λs . λz . m n s z
```

```haskell
GHCi> power 3 4
81
```

## minus

В отличие от всех предыдущих функций, вычитание для натуральных чисел определено только в случае, если уменьшаемое больше вычитаемого. Положим в противном случае результат равным нулю. Пусть уже есть функция, которая вычитает из числа единицу. Тогда на её основе легко сделать, собственно, вычитание.

```haskell
minus=λn . λm . m predn
```

Это то же самое, что m раз вычесть единицу из n.

## pred

Осталось, собственно, функция для вычитания единицы. Однако, это не так просто, как может показаться на первый взгляд. Проблема в том, что, имея функцию, которую нужно применить для того, чтобы продвинуться вперёд, продвинуться назад будет проблематично. Если попробовать воспользоваться идеей о том, чтобы, начав от нуля, идти вперёд, и пройти на один шаг меньше, то будет не очень понятно, как же остановиться ровно за один шаг до конца. Для реализации вычитания единицы сделаем следующее. n раз выполним следующее: имея пару ⟨n−1,n−2⟩ построим пару ⟨n,n−1⟩. Тогда после n шагов во втором элементе пары будет записано число n−1, которое и хочется получить.

```haskell
pred=λn . λs . λz. snd (n (λp . pair (s (fstp)) (fstp)) (pair z z))
```

Если вы ничего не поняли, не огорчайтесь. Вычитание придумал Клини, когда ему вырывали зуб мудрости. А сейчас наркоз уже не тот.
