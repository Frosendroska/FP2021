# Основные встроенные типы языка Haskell. Система модулей. Частичное применение, каррирование.

## Базовые типы
* Bool — булево значение;
* Char — символ Юникода;
* Int, Integer — целые числа;
* Float, Double — числа с плавающей точкой;
* type1 -> type2 — тип функции;
* (type1, type2, ..., typeN) — тип кортежа, N>1;
* () — единичный тип, с одной константой ();
* [type1] — тип списка с элементами типа type1
## Система модулей

* Программа состоит из набора модулей.

* Модули позволяют управлять пространствами имён. 

* Инкапсуляция через списки экспорта и импорта.

Пример модуля

``` haskell
module A (foo, bar) where
import B (f, g, h)
foo = f g
bar = ...
bas = ...
```

Если есть конфликты имен - используем полные имена

``` haskell
import qualified B (f, g, h)
foo = B.f B.g
```

  

## Частичное применение

Рассмотрим функцию foo
``` haskell
foo :: Int -> (Int -> Int) -- Int -> (Int -> Int) == Int -> Int -> Int
foo x y = 10 * x + y
```
Мы знаем, что стрелка правоассоциативна, а вот применение ассоциативно влево, тогда

foo 1 2 == (foo 1) 2

Конструкция foo 1 — это частично применённая функция.

``` haskell
GHCi> :t foo 1
foo 1 :: Int -> Int
GHCi> bar = foo 1
GHCi> :t bar
bar :: Int -> Int
GHCi> bar 2
12
```




## Каррирование

Когда у нас есть фукция с несколькими параметрами, то на самом деле это функция, которая принимает один параметр и возвращает другую функцию (которая возращает другую функцию или уже корректный результат). 

``` haskell
func :: Int -> Double -> Char -> Bool
func :: Int -> (Double -> (Char -> Bool))
```

Каррирование - преобразование функции от многих аргументов в функцию, берущую свои аргументы по одному. В нашем случае много аругементов - tuple

В Data.Tuple определены такие функции:

``` haskell 
curry :: ((a, b) -> c) -> a -> b -> c    -- некаррированная функция в каррированную
uncurry :: (a -> b -> c) -> (a, b) -> c  -- каррированную функцию в некаррированную
```

Давайте рассмотрим пример:

``` HASKELL
msg :: Int -> Bool -> String
msg n True = show $ n `div` 2
msg n _ = show $ n * 2
```

``` haskell
GHCI> let n = msg
GHCI> let m = uncurry n
GHCI> :t n
n :: Int -> Bool -> String
GHCI> :t m
m :: (Int, Bool) -> String
GHCI> n 7 True
"3"
GHCI> m (7, True)
"3"
GHCI> let k = curry m
GHCI> :t k
k :: Int -> Bool -> String
```