# Теория. Билет 16 "Алгоритм унификации" (Денис Шестаков)

## Напоминание

У нас есть понятие унификатора и главного унификатора:

![alt text](https://ie.wampi.ru/2021/12/24/15.9.png)

![alt text](https://ie.wampi.ru/2021/12/24/15.11.png)

Важно помнить, что делая какую-то подстановку, её нужно применять везде,
чтобы все сходилось и мы действительно находили унификатор.

![alt text](https://ie.wampi.ru/2021/12/24/15.10.png)

## Теорема Робинсона

Хочется уметь находить главный унификатор. Для этого у нас есть теорема
Робинсона:

![alt text](https://ie.wampi.ru/2021/12/24/16.1.png)

## Доказательство теоремы

Доказательством теоремы является алгоритм поиска главного унификатора.

![alt text](https://ie.wampi.ru/2021/12/24/16.2.png)

Заметим, что в просто типизированном лямбда исчислении все переменные свободные.
Во второй строчке алгоритма будет ошибка, поскольку мы получаем некое рекурсивное уравнение
на типы - оно неразрешимо. В последней строчке не забываем применить новую полученную 
подстановку к старым типам, чтобы избавиться от коллизий.

Алгоритм завершается. Получается какое-то соображение индукции, которое базируется на том,
что деревья типов конечные. База: первые 3 строчки алгоритма отрабатывают за конечное время. 
Содержательные рассуждение про переход необходимо для 5-ой строчки. По индукции у нас есть *U_2*,
полученное за конечное время. Проблема в том, что после подстановки *U_2 s_1, U_2 t_1*, деревья
для *s_1* и *t_1* могут сильно разрастить. Однако заметим что после такой подстановки, в какую-то
переменную (хотя бы одну) подставляется какое-то выражение, которое эту переменную уже не содержит
(строчки алгоритма 2-3, в противном случае у нас вылетела ошибка). Итого, при унификации за какое-то
конечное время у нас количество переменных в типе сократилось хотя бы на единицу. После унификации 
мы могли создать какие-то новые переменные, однако они являются *свежими*, поэтому мы не будем делать
вместо них подстановку.

Алгоритм унифицирует. Индукция. База: строчки алгоритма 1-3. Переход: нужно доказать 5 строчку.
Ровно то, что написано на слайде. Давайте представим бинарное дерево, у нас есть унификациии *S* и *T*
левого *U(a, b)* и правого *U(c, d)* сыновей. Получается, что мы хотим унифицировать *U(a -> c, b -> d)*.
Понятно, что для этого нам нужно просто взять *S composition T*.

Алгоритм выдает главный унификатор. Это утверждается, никакого рассуждения не требуется.

Пример работы алгоритма унификации:

![alt text](https://ie.wampi.ru/2021/12/24/16.3dbfe29f9122e3fe1.png)

А теперь попробуем поменять местами уравенения в системе и поймем, что действительно ничего
не изменилось

![alt text](https://ie.wampi.ru/2021/12/24/16.4.png)