# Алгебраические типы данных. Сопоставление с образцом, его семантика.

##### Тип суммы
Тип суммы - это перечисление конструкторов, например
```haskell
data Bool = False | True
```
Они представляют собой набор конструкторов, соединенных оператором `|`. Для того, чтобы сконструировать значение перечисления нужно выбрать один конструктор, поэтому оператор `|` читается как «или». Типы построенные с помощью этого оператора называют типами суммы.
В `Prelude`, помимо `Bool`, доступно еще одно полезное перечисление c тремя конструкторами данных.
```haskell
data Ordering = LT | EQ | GT
```
Конечно же мы можем объявлять пользовательские типы данных самостоятельно, используя ключевое слово data. Вот пример пользовательского перечисления с четырьмя конструкторами данных.
```haskell
data CardinalDirection = North | East | South | West
```
Конструкторы данных имеют тип `CardinalDirection`:
```bash
GHCi> dir = North
GHCi> :t dir
dir :: CardinalDirection
```
Однако попытка вывести значение dir приведет к ошибке:
```haskell
GHCi> dir
error: No instance for (Show CardinalDirection)
arising from a use of `print'
In a stmt of an interactive GHCi command: print it
```
Дело в том, что в поток вывода выводится строковое представление для значения типа данных, а как оно должно быть организовано зависит от намерений программиста. За перевод типа данных в строковое представление отвечает класс типов Show. Если мы хотим обеспечить такой перевод для пользовательского типа данных `CardinalDirection`, необходимо реализовать представителя класс типов `Show` для нашего типа. Однако, если нас устраивает простой вывод имени конструктора, можно попросить компилятор сгенерировать этого представителя автоматически, используя механизм производных представителей `(deriving instances)`. Это очень просто сделать, достаточно внести небольшие изменения в объявление типа
```haskell
data CardinalDirection = North | East | South | West deriving Show
```

Механизм производных представителей работает для целого ряда библиотечных классов типов. Поскольку перечисления (и, шире, типы суммы) имеют несколько конструкторов, сопоставление с образцом должно порождать ветвление. Оно достигается определением функции через набор равенств — по равенству на каждый интересный в контексте реализации данной функции образец.

```haskell
hasPole :: CardinalDirection -> Bool
hasPole North = True
hasPole South = True
hasPole _ = False
```
Сопоставление с образцом происходит сверху вниз, до первого удачного
```haskell
GHCi> hasPole South
True
GHCi> hasPole West
False
```
Отметим, что порядок перечисления образцов важен — если в реализации hasPole переместить последнее уравнение вверх, результаты будут другими. Встроенные типы данных ведут себя так, как будто они определены как перечисления:
```haskell
data Char = '\NUL' | ... | 'a' | 'b' | 'c' | 'd' | ...
| '\1114111'
data Int = -9223372036854775808 | ...
| -2 | -1 | 0 | 1 | 2 | ...
| 9223372036854775807
data Integer = ... | -2 | -1 | 0 | 1 | 2 | ...
```
Это позволяет использовать соответствующие литералы как образцы
```haskell 
isAnswer :: Integer -> Bool
isAnswer 42 = True
isAnswer _ = False
```

##### Тип произведения
Тип произведения эквивалентен кортежам соответствующих размеров. Понять, почему этот тип называется произведением можно так: он описывает декартово произведение тех типов, которые в нем лежат.
```haskell
data Point = Pt Double Double deriving Show

origin :: Point
origin = Pt 0.0 0.0

distance :: Point -> Double 
distance (Pt x y) = sqrt (x ^ 2 + y ^ 2)
```
Использование именованных произведений часто более удобно, чем использование кортежей.
Именование конструкторов данных может (в примере выше это `Pt`) быть любым, очень часто, особенно, когда тип данных содержит единственный конструктор (как в `Point`), имя конструктора данных делают таким же, как и имя типа данных (то есть `Point`).

Конструктор данных имеет тип функции, арность которой равна количеству сомножителей тип-произведения. Как и любая функция, конструктор может применяться частично
```bash 
GHCi> :t PtD
PtD :: Double -> Double -> PointDouble
GHCi> :t PtD 3
PtD 3 :: Double -> PointDouble
GHCi> :t PtD 3 5
PtD 3 5 :: PointDouble
```
Однако конструктор данных, в отличие от функции, не имеет никакого кодируемого пользователем вычислительного поведения. Будучи снабженным требуемым количеством фактических аргументов, он просто порождает значение целевого типа, выступающее в роли хранилища для выражений-аргументов.
Сопоставление с образцом для типа-произведения решает обратную задачу — извлечение выражений из этого хранилища и связывания их с именами для дальнейшего использования. Вот, например, функция, которая по переданным координатам двух точек ищет координаты середины соединяющего эти точки отрезка:
```haskell
midPointDouble :: PointDouble -> PointDouble -> PointDouble
midPointDouble (PtD x1 y1) (PtD x2 y2) =
PtD ((x1 + x2) / 2) ((y1 + y2) / 2)
```
Координаты точек-аргументов функции связываются в образце с переменными и обрабатываются в правой части для получения координат середины отрезка:
```bash
GHCi> midPointDouble (PtD 3 5) (PtD 9 8)
PtD 6.0 6.5
```

###### Полиморфные типы
Тип данных PointDouble был создан в представлении, что координаты точки имеют тип Double. Однако могут возникнуть ситуации, когда удобнее иметь координаты типа
Float или вообще целочисленные, например, Int. Универсальным решением будет сделать тип точки полиморфным по типу координат. Для этого нужно параметризовать тип точки т´иповым параметром:
```haskell
data Point a = Pt a a
    deriving Show
```
Теперь тип конструктора данных полиморфен
```bash
GHCi> :type Pt
Pt :: a -> a -> Point a
```
и мы можем создавать точки с разными типами координат
```bash
GHCi> pDbl = Pt (3::Double) (5::Double)
GHCi> pDbl
Pt 3.0 5.0
GHCi> pInt = Pt (3::Int) (5::Int)
GHCi> pInt
Pt 3 5
GHCi> :t pDbl
pDbl :: Point Double
GHCi> :t pInt
pInt :: Point Int
```
Сам по себе конструктор типа `Point` становится теперь не обычным типом, а функцией над типами (чаще говорят оператор над типами, хотя это не оператор в смысле Haskell). Конкретный тип, напирмер, `Point Int` получается применением конструктора
типа к обычному типу; в нашем случае к `Int`. Обратим внимание, что здесь используется тот же минималистичный синтаксис применения, что и при построении выражений, хотя речь идет о построении типов!
Конструктор типа `Point` имеет один типовый параметр a. Это значит, что его применения `Point Int` или `Point Double` допустимы, а, например, `Point Int Double` нет.
Очевидно, что конструкция `Point Point` тоже должна быть отвергнута: хотя число параметров здесь подходящее, тип параметра не тот что нужен. Постойте-ка, мы заговорили о типе типа! Для статического контроля подобного рода в Haskell имеется система типов над системой типов, которая для избежания путаницы называется системой кайндов.
Система кайндов структурно повторяет систему типов Haskell, однако базовый кайнд всего один — *. Все простые типы имеют этот кайнд. К простым относятся все типы, которые нами использовались справа в отношении типизации ::, в том числе и стрелочные. Этот же оператор :: используется для отношения «кайндизации» в системе кайндов. Ровно так же как в системе типов утверждение 42 :: Int читалось как «42 — это целое», в системе кайндов утверждение `Int` :: * читается как «`Int` — это (простой) тип». Утверждение `(+5) :: Int -> Int`, читающееся как «`(+5)` — это функция с одним параметром из `Int` в `Int`», в системе кайндов имеет аналог `Point :: * -> *`, который читается как «`Point` — это однопараметрический оператор из простого типа в простой тип».
GHCi позволяет анализировать кайнды как пользовательских типов
```bash
GHCi> :kind Point
Point :: * -> *
GHCi> :kind Point Int
Point Int :: *
```
так и встроенных
```bash
GHCi> :k []
[] :: * -> *
GHCi> :k [] Int
[] Int :: *
GHCi> :k [Int]
[Int] :: *
GHCi> :k (,)
(,) :: * -> * -> *
GHCi> :k (,) Char
(,) Char :: * -> *
GHCi> :k (,) Char Bool
(,) Char Bool :: *
GHCi> :k (Char,Bool)
(Char,Bool) :: *
GHCi> :k Int -> Int -> Int
Int -> Int -> Int :: *
GHCi> :k (->)
(->) :: * -> * -> *
GHCi> :k (->) Int
(->) Int :: * -> *
GHCi> :k (->) Int Bool
(->) Int Bool :: *
```

###### Полиморфные функции над полиморфными типами
Полиморфные типы данных полиморфны параметрически, то есть на типовый параметр a в типе Point a невозможно наложить ad hoc ограничения20. Однако при реализации функций над полиморфными типами подобные ограничения допустимы. Например, в общем случае невозможно найти середину отрезка, если координаты вершин целочисленны. Поэтому в полиморфном обобщении подобной функции возникает контекст `Fractional`:
```haskell
midPoint :: Fractional a => Point a -> Point a -> Point a
midPoint (Pt x1 y1) (Pt x2 y2) =
    Pt ((x1 + x2) / 2) ((y1 + y2) / 2)
```
Контекст `Fractional` нет необходимости писать руками, он выводится автоматически
из использования в теле функции оператора (`/`). Если бы в теле использовался только
оператор сложения, мы бы имели более общий контекст `Num`
```bash
GHCi> :t midPoint (Pt 3 5) (Pt 9 8)
midPoint (Pt 3 5) (Pt 9 8) :: Fractional a => Point a
GHCi> midPoint (Pt 3 5) (Pt 9 8)
Pt 6.0 6.5
```
###### Стандартные алгебраические типы
В стандартной библиотеке помимо кортежей и списков имеется несколько полезных
полиморфных типов общего назначения.
Тип `Maybe` a позволяет добавить к произвольному типу a дополнительное необязательное значение
```haskell
data Maybe a = Nothing | Just a
```
Конструктор `Just` оборачивает «регулярное» значение, а `Nothing` играет роль дополнительного элемента. Для извлечения значения можно использовать сопоставление с
образцом или библиотечную функцию-элиминатор (из модуля `Data.Maybe`)
```haskell
maybe :: b -> (a -> b) -> Maybe a -> b
```
Эта функция позволяет по переданному значению типа `Maybe a` получить значение
произвольного типа `b`, если у нас имеется обработчик типа `a -> b` для «регулярных»
значений и значение типа `b` для случая `Nothing`. Например,
```bash
GHCi> maybe (-1) length $ Just "ABCDE"
5
GHCi> maybe (-1) length $ Just ""
0
GHCi> maybe (-1) length Nothing
```
Другим примером использования типа `Maybe` может служить библиотечная функция
поиска элемента списка, удовлетворяющего предикату:
```haskell
find :: (a -> Bool) -> [a] -> Maybe a
```
Если элемент, удовлетворяющий предикату, отсутствует, возвращается `Nothing`
```bash
GHCi> find (>10) [7,5,12,16]
Just 12
GHCi> find (>20) [7,5,12,16]
Nothing
```

Тип `Either` a b хранит одно значение из двух, являясь типом-суммой двух произвольных типов
```haskell
data Either a b = Left a | Right b
```
Этот тип является стандартным библиотечным способом построить сумму типов, взяв два существующих типа. В этом он похож на стандартный двухэлементный кортеж (пару), которая обеспечивает стандартный способ построить произведение двух типов. В модуле `Data.Either` определен стандартный элиминатор для типа `Either`
```haskell
either :: (a -> c) -> (b -> c) -> Either a b -> c
```
С помощью `Either` обычно описывают вычисления, в которых возможны проблемные
результаты. Конструктор данных `Right` используют для упаковки успешных результатов, а `Left` — для реакции на неудачу.
```haskell
(/?) :: (Eq a, Fractional a) => a -> a -> Either String a
x /? 0 = Left "(/?) error: division by zero"
x /? y = Right (x / y)
```

```bash
GHCi> 6 /? 2
Right 3.0
GHCi> 6 /? 0
Left "(/?) error: division by zero"
GHCi> :t either id show
either id show :: Show a => Either String a -> String
GHCi> either id show (6 /? 2)
"3.0"
GHCi> either id show (6 /? 0)
"(/?) error: division by zero"
```
На основе типа `Either` в `Haskell` построен стандартный монадический механизм обработки исключений.
И `Maybe` и `Either` представляют собой суммы типов. При этом слагаемые в трех случаях из четырех можно рассматривать как типы-произведения из одного сомножителя, а в четвертом (`Nothing`) — из нуля сомножителей.


##### Тип суммы произведений:

```haskell
data Roots = Roots Double Double | None 
    deriving Show
```
Тогда, например, при поиске корней квадратного уравнения при отрицательном дискриминанте будет следующая ситуация:
```haskell 
roots :: Double -> Double -> Double -> Roots
roots a b c
    | discr >= 0 = Roots x1 x2
    | otherwise = None
    where 
        x1 = helper (-d)
        x2 = helper d
        helper x = (-b + x) / (2 * a)
        d = sqrt discr
        discr = b ^ 2 - 4 * a * c
```

Таким образом, на уровне типов мы организовали проверку поведения функций.


#####  Экспоненциальные типы
Экспоненциальный тип — это тип функции. Такое название происходит из наблюдения
за мощностями типов, то есть количеством их элементов. У типа `Bool` мощность равна 2, 
у типа `Ordering` — 3. У типа их суммы `Either Bool Ordering` мощность равна 2+3 = 5.
У типа их произведения `(Bool,Ordering)` имеется 2 ∗ 3 = 6 различных элементов.
Если посчитать число различных функций типа Bool -> Ordering, то окажется, что их 3^2 = 9. Если же посчитать число различных функций типа Ordering -> Bool, то окажется, что их 2^3 = 8. Иными словами, на вполне разумных основаниях вместо стандартного встроенного типа функции a -> b можно было бы использовать нотацию b ^ a.
**Экспонециальный (или функциональный) тип** — это полноценный тип языка, его можно использовать всюду, где мы можем писать произвольный тип. В частности, мы можем использовать его в качестве типа аргумента конструктора данных: 
```haskell
data Endom a = Endom (a -> a)`
```
Этот тип представляет собой контейнер для хранения функции, у которой область определения и множество значений совпадают. Можно написать элиминатор для извлечения функции из такого контейнера:
```haskell
appEndom :: Endom a -> a -> a
appEndom (Endom f) = f
```
Извлечение функции происходит при частичном применении элиминатора
```bash
GHCi> e = Endom (\n -> 2 * n + 3)
GHCi> :t e
e :: Num a => Endom a
GHCi> :t appEndom e
appEndom e :: Num a => a -> a
```
А полное применение `appEndom` дает извлечение-а-затем-применение
```bash
GHCi> e `appEndom` 5
13
```
У экспоненциального типа есть оно отличие от типов суммы и произведения. Мы не можем «разобрать» такой тип с помощью сопоставления с образцом, переменная является единственным подходящим образцом для функционального аргумента.

##### Рекурсивные типы
При объявлении типов можно использовать рекурсию. Это значит, что допустимо указывать объявляемый тип в качестве аргумента конструктора данных:
```bash
GHCi> data Nat = Zero | Suc Nat deriving Show
```
Конструктор `Suc` при этом оказывается эндоморфизмом над типом Nat
```bash
GHCi> :t Zero
Zero :: Nat
GHCi> :t Suc
Suc :: Nat -> Nat

Это позволяет строить неограниченное число обитателей данного типа:
```bash
GHCi> one = Suc Zero
GHCi> two = Suc (Suc Zero)
GHCi> three = Suc two
GHCi> four = Suc three
...

Это так называемые числа Пеано. Их можно рассматривать как способ кодирования натуральных чисел в унарной системе исчисления. Поскольку тип Nat это тип суммы, тотальные функции над ним, использующие опровержимые образцы, определяются
несколькими равенствами
```bash
GHCi> {pred (Suc n) = n; pred Zero = Zero}
GHCi> pred two
Suc Zero
```
Другим примером рекурсивного типа служит список. Хотя встроенный список имеет специальный синтаксис, мы можем определить полностью эквивалентный ему пользовательский тип списка
```haskell
data List a = Nil | Cons a (List a)
    deriving Show
```
Конструкторы данных типа `List` имеют типы
```haskell
Nil :: List a
Cons :: a -> List a -> List a
```

Пользовательские функции над рекурсивными типами данных удобно писать через сопоставление с образцом и рекурсию
```haskell
len :: List a -> Int
len Nil = 0
len (Cons _ xs) = 1 + len xs
```
Рекурсия в типах позволяет строить конструкции произвольной степени вложенности,
а рекурсия в функциях дает возможность эти конструкции обрабатывать:
```bash
GHCi> myList = Cons 'a' (Cons 'b' (Cons 'c' Nil))
GHCi> len myList
3
```

#### Сопоставление с образцом
При вызове функции, например, следующей:
```haskell
not :: Bool -> Bool
not True = False
not False = True
```
происходит сопоставление с образцом: выбирается то равенство,
которое соответствует фактически переданному аргументу. Если в качестве аргумента
передается не значение, а выражение, то, несмотря на ленивую природу языка, вычисление этого выражения форсируется. Это оправдано, поскольку иначе невозможно
выбрать подходящее равенство, а значит невозможно продолжить вычисление. Именно
этот механизм обеспечивает расходимость функции
```haskell
bot :: Bool
bot = not bot
```

Если тип имеет несколько конструкторов данных, то функция нескольких переменных для него задается путем сопоставления с нужным для реализации этой функции числом образцов. Допустимо вперемешку использовать в качестве формальных аргументов функций как переменные, так и конструкторы. Образцами называется и то и другое. При этом сопоставление с переменной всегда удачно.

##### Семантика сопоставления с образцом
Поскольку определение функции может содержать
- несколько равенств;
- несколько аргументов-образцов в каждом равенстве;
- вложенные подобразцы в каждом образце

требуются объемные правила сопоставления. Общий принцип, однако, описать довольно просто: сопоставление с образцом происходит сверху-вниз, затем слеванаправо. Результат сопоставления с образцом может быть
- успешным (succeed);
- неудачным (fail);
- расходящимся (diverge).

Успех означает, что мы можем переходить к правой части текущего равенства. Разница между неудачей и расходимостью такова: при неудаче мы просто переходим к
следующему равенства, а расходимость аварийно завершает работу.
Образцам помимо конструкторов называют также переменные и подчеркивание.
Последние два вида образцов относят к ***неопровержимым*** (irrefutable). Неопровержимы те образцы, сопоставление с которыми всегда успешно. Образец, сопоставление с которым может завершиться отличным от успеха исходом называют ***опровержимым*** (refutable).
Посмотрим как работают приведенные правила на примере функции
```haskell
bar 1 2 = 3
bar 0 _ = 5
```
Вызов `bar 1 2` приводит к успеху на первом же равенстве. Вызов `bar 0 7` неудачен на
первом равенстве, и успешен на втором. Вызов `bar 2 1` — две неудачи и, как следствие,
расходимость.
Вызов `bar 1 (5-3)` будет успешен на первом равенстве. Однако для того, чтобы удостовериться в этом, системе времени исполнения придется форсировать вычисление аргумента. Это добавляет в ленивый язык некоторую (необходимую) степень энергичности. Однако вычисление форсируется только до слабой головной нормальной формы (WHNF): достаточно получить на верхнем уровне некоторый конструктор данных. Все, что находится за его барьером, остается не вычисленным.
Вызов `bar 1 undefined` приводит к расходимости в первом же образце.
Однако вызов `bar 0 undefined` возвращает 5, то есть он неудачен (но не расходится!) в первом образце и успешен во втором. Здесь срабатывает правило «слева направо»: в первом равенстве неудача сопоставления фактического 0 с ожидаемой 1 приводит к тому, что все сопоставление объявляется неудачным, дело просто не доходит до потенциальной расходимости.

###### Ленивые образцы
Ленивые образцы - еще один тип неопровержимых образцов (то есть это конструктор с каким-то количеством параметров), к таким образцам приписан знак тильды `~`, сопоставление с таким образцом всегда должно завершаться удачей.
```haskell
fromMaybe ~(Just x) = x
fromMaybe Nothing = error "!!!" -- сюда никогда не доберемся
```
Пример использования:
```haskell
(***) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
(***) f g ~(x, y) = (f x, g y)
```

##### Сопоставление с образцом в правой части выражения
Все языковые конструкции содержащие образцы при трансляции в Kernel превращаются в выражение `case ... of ....` Например, функция
```haskell
head (x:_) = x
head [] = error "head: empty list"
```
транслируется в Kernel следующим образом
```haskell
head'' xs = case xs of { (x:_) -> x; [] -> error "head'': empty list" }
```

Как обычно нотация с фигурными скобками может быть заменена на более удобную
форму записи с отступами
```haskell
head'' xs = 
    case xs of 
        (x:_) -> x
        [] -> error "head'': empty list"  
```
Общее правило трансляции сопоставления с образцом таково: функция
```haskell
f p11 ... p1k -> e1
...
f pn1 ... pnk -> en
```
транслируется в Kernel следующим образом
```haskell
f x1 ... xk = case (x1,...,xk)
(p11,...,p1k) -> e1
...
(pn1,...,pnk) -> en
```
Здесь (и в целом в правилах трансляции) pij — метапеременные, маркирующие образцы, а xj — переменные. Про последние оговаривается, что они свежие, то есть отличные
от всех других переменных в программе.
Поскольку `case ... of ...` — выражение, его можно использовать в любом месте
кода:
```bash
GHCi> f v = (case v of Just x -> x; Nothing -> 2) ^ 2
GHCi> f (Just 5)
25
GHCi> f Nothing
4
```
Такое поведение полезно, когда возникает необходимость выполнить сопоставление с
образцом некоторой переменной в процессе реализации тела функции.

[Более подробно об образцах в параграфе 7 конспекта](https://wiki.compscicenter.ru/images/9/9e/TextHASK20211215.pdf)


